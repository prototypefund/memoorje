/* tslint:disable */
/* eslint-disable */
/**
 * Memoorje API
 * Sicherer, selbstverwalteter digitaler Nachlass f√ºr alle
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ChangePassword,
    ChangePasswordFromJSON,
    ChangePasswordToJSON,
    DefaultLogin,
    DefaultLoginFromJSON,
    DefaultLoginToJSON,
    DefaultRegisterEmail,
    DefaultRegisterEmailFromJSON,
    DefaultRegisterEmailToJSON,
    DefaultRegisterUser,
    DefaultRegisterUserFromJSON,
    DefaultRegisterUserToJSON,
    DefaultSendResetPasswordLink,
    DefaultSendResetPasswordLinkFromJSON,
    DefaultSendResetPasswordLinkToJSON,
    DefaultUserProfile,
    DefaultUserProfileFromJSON,
    DefaultUserProfileToJSON,
    Logout,
    LogoutFromJSON,
    LogoutToJSON,
    ResetPassword,
    ResetPasswordFromJSON,
    ResetPasswordToJSON,
    VerifyEmail,
    VerifyEmailFromJSON,
    VerifyEmailToJSON,
    VerifyRegistration,
    VerifyRegistrationFromJSON,
    VerifyRegistrationToJSON,
} from '../models';

export interface AuthChangePasswordCreateRequest {
    oldPassword: string;
    password: string;
    passwordConfirm: string;
}

export interface AuthLoginCreateRequest {
    login: string;
    password: string;
}

export interface AuthLogoutCreateRequest {
    revokeToken?: boolean;
}

export interface AuthProfileCreateRequest {
    id: number;
    email: string;
    name?: string;
}

export interface AuthProfilePartialUpdateRequest {
    id?: number;
    email?: string;
    name?: string;
}

export interface AuthProfileUpdateRequest {
    id: number;
    email: string;
    name?: string;
}

export interface AuthRegisterCreateRequest {
    id: number;
    password: string;
    email: string;
    passwordConfirm: string;
    name?: string;
}

export interface AuthRegisterEmailCreateRequest {
    email: string;
}

export interface AuthResetPasswordCreateRequest {
    userId: string;
    timestamp: number;
    signature: string;
    password: string;
}

export interface AuthSendResetPasswordLinkCreateRequest {
    login: string;
}

export interface AuthVerifyEmailCreateRequest {
    userId: string;
    email: string;
    timestamp: number;
    signature: string;
}

export interface AuthVerifyRegistrationCreateRequest {
    userId: string;
    timestamp: number;
    signature: string;
}

/**
 * 
 */
export class AuthApi extends runtime.BaseAPI {

    /**
     * Change the user password.
     */
    async authChangePasswordCreateRaw(requestParameters: AuthChangePasswordCreateRequest): Promise<runtime.ApiResponse<ChangePassword>> {
        if (requestParameters.oldPassword === null || requestParameters.oldPassword === undefined) {
            throw new runtime.RequiredError('oldPassword','Required parameter requestParameters.oldPassword was null or undefined when calling authChangePasswordCreate.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authChangePasswordCreate.');
        }

        if (requestParameters.passwordConfirm === null || requestParameters.passwordConfirm === undefined) {
            throw new runtime.RequiredError('passwordConfirm','Required parameter requestParameters.passwordConfirm was null or undefined when calling authChangePasswordCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.oldPassword !== undefined) {
            formParams.append('oldPassword', requestParameters.oldPassword as any);
        }

        if (requestParameters.password !== undefined) {
            formParams.append('password', requestParameters.password as any);
        }

        if (requestParameters.passwordConfirm !== undefined) {
            formParams.append('passwordConfirm', requestParameters.passwordConfirm as any);
        }

        const response = await this.request({
            path: `/api/auth/change-password/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangePasswordFromJSON(jsonValue));
    }

    /**
     * Change the user password.
     */
    async authChangePasswordCreate(requestParameters: AuthChangePasswordCreateRequest): Promise<ChangePassword> {
        const response = await this.authChangePasswordCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Logs in the user via given login and password.
     */
    async authLoginCreateRaw(requestParameters: AuthLoginCreateRequest): Promise<runtime.ApiResponse<DefaultLogin>> {
        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling authLoginCreate.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authLoginCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.login !== undefined) {
            formParams.append('login', requestParameters.login as any);
        }

        if (requestParameters.password !== undefined) {
            formParams.append('password', requestParameters.password as any);
        }

        const response = await this.request({
            path: `/api/auth/login/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultLoginFromJSON(jsonValue));
    }

    /**
     * Logs in the user via given login and password.
     */
    async authLoginCreate(requestParameters: AuthLoginCreateRequest): Promise<DefaultLogin> {
        const response = await this.authLoginCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Logs out the user. returns an error if the user is not authenticated.
     */
    async authLogoutCreateRaw(requestParameters: AuthLogoutCreateRequest): Promise<runtime.ApiResponse<Logout>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.revokeToken !== undefined) {
            formParams.append('revokeToken', requestParameters.revokeToken as any);
        }

        const response = await this.request({
            path: `/api/auth/logout/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LogoutFromJSON(jsonValue));
    }

    /**
     * Logs out the user. returns an error if the user is not authenticated.
     */
    async authLogoutCreate(requestParameters: AuthLogoutCreateRequest): Promise<Logout> {
        const response = await this.authLogoutCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get or set user profile.
     */
    async authProfileCreateRaw(requestParameters: AuthProfileCreateRequest): Promise<runtime.ApiResponse<DefaultUserProfile>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling authProfileCreate.');
        }

        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authProfileCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id !== undefined) {
            formParams.append('id', requestParameters.id as any);
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
                    }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        const response = await this.request({
            path: `/api/auth/profile/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultUserProfileFromJSON(jsonValue));
    }

    /**
     * Get or set user profile.
     */
    async authProfileCreate(requestParameters: AuthProfileCreateRequest): Promise<DefaultUserProfile> {
        const response = await this.authProfileCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get or set user profile.
     */
    async authProfilePartialUpdateRaw(requestParameters: AuthProfilePartialUpdateRequest): Promise<runtime.ApiResponse<DefaultUserProfile>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id !== undefined) {
            formParams.append('id', requestParameters.id as any);
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
                    }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        const response = await this.request({
            path: `/api/auth/profile/`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultUserProfileFromJSON(jsonValue));
    }

    /**
     * Get or set user profile.
     */
    async authProfilePartialUpdate(requestParameters: AuthProfilePartialUpdateRequest): Promise<DefaultUserProfile> {
        const response = await this.authProfilePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get or set user profile.
     */
    async authProfileRetrieveRaw(): Promise<runtime.ApiResponse<DefaultUserProfile>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/auth/profile/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultUserProfileFromJSON(jsonValue));
    }

    /**
     * Get or set user profile.
     */
    async authProfileRetrieve(): Promise<DefaultUserProfile> {
        const response = await this.authProfileRetrieveRaw();
        return await response.value();
    }

    /**
     * Get or set user profile.
     */
    async authProfileUpdateRaw(requestParameters: AuthProfileUpdateRequest): Promise<runtime.ApiResponse<DefaultUserProfile>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling authProfileUpdate.');
        }

        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authProfileUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id !== undefined) {
            formParams.append('id', requestParameters.id as any);
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
                    }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        const response = await this.request({
            path: `/api/auth/profile/`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultUserProfileFromJSON(jsonValue));
    }

    /**
     * Get or set user profile.
     */
    async authProfileUpdate(requestParameters: AuthProfileUpdateRequest): Promise<DefaultUserProfile> {
        const response = await this.authProfileUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Register new user.
     */
    async authRegisterCreateRaw(requestParameters: AuthRegisterCreateRequest): Promise<runtime.ApiResponse<DefaultRegisterUser>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling authRegisterCreate.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authRegisterCreate.');
        }

        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authRegisterCreate.');
        }

        if (requestParameters.passwordConfirm === null || requestParameters.passwordConfirm === undefined) {
            throw new runtime.RequiredError('passwordConfirm','Required parameter requestParameters.passwordConfirm was null or undefined when calling authRegisterCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id !== undefined) {
            formParams.append('id', requestParameters.id as any);
        }

        if (requestParameters.password !== undefined) {
            formParams.append('password', requestParameters.password as any);
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
                    }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.passwordConfirm !== undefined) {
            formParams.append('passwordConfirm', requestParameters.passwordConfirm as any);
        }

        const response = await this.request({
            path: `/api/auth/register/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultRegisterUserFromJSON(jsonValue));
    }

    /**
     * Register new user.
     */
    async authRegisterCreate(requestParameters: AuthRegisterCreateRequest): Promise<DefaultRegisterUser> {
        const response = await this.authRegisterCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Register new email.
     */
    async authRegisterEmailCreateRaw(requestParameters: AuthRegisterEmailCreateRequest): Promise<runtime.ApiResponse<DefaultRegisterEmail>> {
        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authRegisterEmailCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
                    }

        const response = await this.request({
            path: `/api/auth/register-email/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultRegisterEmailFromJSON(jsonValue));
    }

    /**
     * Register new email.
     */
    async authRegisterEmailCreate(requestParameters: AuthRegisterEmailCreateRequest): Promise<DefaultRegisterEmail> {
        const response = await this.authRegisterEmailCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Reset password, given the signature and timestamp from the link.
     */
    async authResetPasswordCreateRaw(requestParameters: AuthResetPasswordCreateRequest): Promise<runtime.ApiResponse<ResetPassword>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling authResetPasswordCreate.');
        }

        if (requestParameters.timestamp === null || requestParameters.timestamp === undefined) {
            throw new runtime.RequiredError('timestamp','Required parameter requestParameters.timestamp was null or undefined when calling authResetPasswordCreate.');
        }

        if (requestParameters.signature === null || requestParameters.signature === undefined) {
            throw new runtime.RequiredError('signature','Required parameter requestParameters.signature was null or undefined when calling authResetPasswordCreate.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling authResetPasswordCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.userId !== undefined) {
            formParams.append('userId', requestParameters.userId as any);
        }

        if (requestParameters.timestamp !== undefined) {
            formParams.append('timestamp', requestParameters.timestamp as any);
        }

        if (requestParameters.signature !== undefined) {
            formParams.append('signature', requestParameters.signature as any);
        }

        if (requestParameters.password !== undefined) {
            formParams.append('password', requestParameters.password as any);
        }

        const response = await this.request({
            path: `/api/auth/reset-password/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ResetPasswordFromJSON(jsonValue));
    }

    /**
     * Reset password, given the signature and timestamp from the link.
     */
    async authResetPasswordCreate(requestParameters: AuthResetPasswordCreateRequest): Promise<ResetPassword> {
        const response = await this.authResetPasswordCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Send email with reset password link.
     */
    async authSendResetPasswordLinkCreateRaw(requestParameters: AuthSendResetPasswordLinkCreateRequest): Promise<runtime.ApiResponse<DefaultSendResetPasswordLink>> {
        if (requestParameters.login === null || requestParameters.login === undefined) {
            throw new runtime.RequiredError('login','Required parameter requestParameters.login was null or undefined when calling authSendResetPasswordLinkCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.login !== undefined) {
            formParams.append('login', requestParameters.login as any);
        }

        const response = await this.request({
            path: `/api/auth/send-reset-password-link/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultSendResetPasswordLinkFromJSON(jsonValue));
    }

    /**
     * Send email with reset password link.
     */
    async authSendResetPasswordLinkCreate(requestParameters: AuthSendResetPasswordLinkCreateRequest): Promise<DefaultSendResetPasswordLink> {
        const response = await this.authSendResetPasswordLinkCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verify email via signature.
     */
    async authVerifyEmailCreateRaw(requestParameters: AuthVerifyEmailCreateRequest): Promise<runtime.ApiResponse<VerifyEmail>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling authVerifyEmailCreate.');
        }

        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling authVerifyEmailCreate.');
        }

        if (requestParameters.timestamp === null || requestParameters.timestamp === undefined) {
            throw new runtime.RequiredError('timestamp','Required parameter requestParameters.timestamp was null or undefined when calling authVerifyEmailCreate.');
        }

        if (requestParameters.signature === null || requestParameters.signature === undefined) {
            throw new runtime.RequiredError('signature','Required parameter requestParameters.signature was null or undefined when calling authVerifyEmailCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.userId !== undefined) {
            formParams.append('userId', requestParameters.userId as any);
        }

        if (requestParameters.email !== undefined) {
            formParams.append('email', requestParameters.email as any);
                    }

        if (requestParameters.timestamp !== undefined) {
            formParams.append('timestamp', requestParameters.timestamp as any);
        }

        if (requestParameters.signature !== undefined) {
            formParams.append('signature', requestParameters.signature as any);
        }

        const response = await this.request({
            path: `/api/auth/verify-email/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifyEmailFromJSON(jsonValue));
    }

    /**
     * Verify email via signature.
     */
    async authVerifyEmailCreate(requestParameters: AuthVerifyEmailCreateRequest): Promise<VerifyEmail> {
        const response = await this.authVerifyEmailCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verify registration via signature.
     */
    async authVerifyRegistrationCreateRaw(requestParameters: AuthVerifyRegistrationCreateRequest): Promise<runtime.ApiResponse<VerifyRegistration>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling authVerifyRegistrationCreate.');
        }

        if (requestParameters.timestamp === null || requestParameters.timestamp === undefined) {
            throw new runtime.RequiredError('timestamp','Required parameter requestParameters.timestamp was null or undefined when calling authVerifyRegistrationCreate.');
        }

        if (requestParameters.signature === null || requestParameters.signature === undefined) {
            throw new runtime.RequiredError('signature','Required parameter requestParameters.signature was null or undefined when calling authVerifyRegistrationCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
            { contentType: 'multipart/form-data' },
            { contentType: 'application/json' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.userId !== undefined) {
            formParams.append('userId', requestParameters.userId as any);
        }

        if (requestParameters.timestamp !== undefined) {
            formParams.append('timestamp', requestParameters.timestamp as any);
        }

        if (requestParameters.signature !== undefined) {
            formParams.append('signature', requestParameters.signature as any);
        }

        const response = await this.request({
            path: `/api/auth/verify-registration/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifyRegistrationFromJSON(jsonValue));
    }

    /**
     * Verify registration via signature.
     */
    async authVerifyRegistrationCreate(requestParameters: AuthVerifyRegistrationCreateRequest): Promise<VerifyRegistration> {
        const response = await this.authVerifyRegistrationCreateRaw(requestParameters);
        return await response.value();
    }

}
